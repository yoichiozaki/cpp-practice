# 連続する部分列のうち最長のもの -> sliding window を思いつきたいところ
# 最大で k 個 0 を含む部分列のうち最長のものの長さを取る問題と言い換える
# ほしいのは最長の長さなので、左端要素が切り替わったタイミングで、直前までの長さを保存する意図で右端要素を左のほうにリセットする必要はない。伸ばせるだけ伸ばせばいいし、伸ばせないならそこで止めればよくて、縮める必要はない。
class Solution:
    def longestOnes(self, nums: List[int], k: int) -> int:
        left = 0
        for right in range(len(nums)):
            if nums[right] == 0: # 右端が 0 なので k を消費して 1 にする
                k -= 1
            if k < 0: # k が足りないので左端を動かして補給する必要がある
                if nums[left] == 0: # ちょうど左端が 0 なら k を補給できる
                    k += 1
                left += 1 # ここで左端を動かして、右端はそのままでよい。なぜならほしいのは最長の長さなので、左端を更新したタイミングの正確な右端の位置を知る必要はないから。
        return right - left + 1